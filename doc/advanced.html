
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Advanced Use &mdash; LEPL 5.1.2 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '5.1.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="LEPL 5.1.2 documentation" href="index.html" />
    <link rel="up" title="Lepl Manual" href="manual.html" />
    <link rel="next" title="Patterns" href="style.html" />
    <link rel="prev" title="Line–Aware Parsing and the Offside Rule" href="offside.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="style.html" title="Patterns"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="offside.html" title="Line–Aware Parsing and the Offside Rule"
             accesskey="P">previous</a> |</li>
        <li><a href="contents.html">LEPL 5.1.2 documentation</a> &raquo;</li>
          <li><a href="manual.html" accesskey="U">Lepl Manual</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="advanced-use">
<h1>Advanced Use<a class="headerlink" href="#advanced-use" title="Permalink to this headline">¶</a></h1>
<div class="section" id="configuration">
<span id="index-0"></span><span id="id1"></span><h2>Configuration<a class="headerlink" href="#configuration" title="Permalink to this headline">¶</a></h2>
<p>A <tt class="docutils literal"><span class="pre">.config</span></tt> attribute on the matcher is used to specify options.  This means
that you can explore the available options at the Python prompt (and perhaps
via some IDEs).</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">matcher</span><span class="o">.</span><span class="n">config</span><span class="p">)</span>
<span class="go">[..., &#39;add_monitor&#39;, &#39;add_rewriter&#39;, &#39;add_stream_kargs&#39;, &#39;alphabet&#39;,</span>
<span class="go">&#39;auto_memoize&#39;, &#39;cache_level&#39;, &#39;changed&#39;, &#39;clear&#39;, &#39;clear_cache&#39;,</span>
<span class="go">&#39;compile_to_dfa&#39;, &#39;compile_to_nfa&#39;, &#39;compile_to_re&#39;, &#39;compose_transforms&#39;,</span>
<span class="go">&#39;configuration&#39;, &#39;default&#39;, &#39;direct_eval&#39;, &#39;flatten&#39;, &#39;full_first_match&#39;,</span>
<span class="go">&#39;left_memoize&#39;, &#39;lexer&#39;, &#39;lines&#39;, &#39;low_memory&#39;, &#39;matcher&#39;,</span>
<span class="go">&#39;no_compile_to_regexp&#39;, &#39;no_compose_transforms&#39;, &#39;no_direct_eval&#39;,</span>
<span class="go">&#39;no_flatten&#39;, &#39;no_full_first_match&#39;, &#39;no_lexer&#39;, &#39;no_memoize&#39;,</span>
<span class="go">&#39;no_optimize_or&#39;, &#39;no_set_arguments&#39;, &#39;optimize_or&#39;, &#39;record_deepest&#39;,</span>
<span class="go">&#39;remove_all_monitors&#39;, &#39;remove_all_rewriters&#39;, &#39;remove_all_stream_kargs&#39;,</span>
<span class="go">&#39;remove_rewriter&#39;, &#39;right_memoize&#39;, &#39;set_alphabet_arg&#39;, &#39;set_arguments&#39;,</span>
<span class="go">&#39;stream_factory&#39;, &#39;trace_stack&#39;, &#39;trace_variables&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="n">matcher</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">compile_to_dfa</span><span class="p">)</span>
<span class="go">Help on method compile_to_dfa in module lepl.core.config:</span>
<span class="go">compile_to_dfa(self, force=False, alphabet=None) method of lepl.core.config.ConfigBuilder instance</span>
<span class="go">    Compile simple matchers to DFA regular expressions.  This improves</span>
<span class="go">    efficiency but may change the parser semantics slightly (DFA regular</span>
<span class="go">    expressions do not provide backtracking / alternative matches).</span>
</pre></div>
</div>
<p>Also, note that configuration methods can be chained together, making
configuration code more compact:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">matcher</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span><span class="o">.</span><span class="n">lexer</span><span class="p">()</span>
</pre></div>
</div>
<p>The main options available are described in the following sections.  In
addition, <a class="reference internal" href="examples.html#config-example"><em>this example</em></a> shows the effect of different
options on parsing times.</p>
<div class="section" id="common-packaged-actions">
<span id="index-1"></span><h3>Common, Packaged Actions<a class="headerlink" href="#common-packaged-actions" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.default">.config.default()</a></p>
<blockquote>
<div><p>This sets the default configuration.  It is not needed when first using a
matcher, but can be useful to &#8220;reset&#8221; a matcher to the default state.</p>
<p>The default configuration is intended for safe, simple use.  It can
sometimes be made more efficient by calling <a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.no_memoize">.config.no_memoize()</a>,
at the risk of infinite loops with left-recursive grammars.</p>
</div></blockquote>
<p><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.clear">.config.clear()</a></p>
<blockquote>
<div>This empties the current configuration (for example, removing the default
settings).  If this is <em>not</em> used then any alterations are <em>relative</em> to the
default settings.</div></blockquote>
<p><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.lines">.config.lines()</a></p>
<blockquote>
<div>Enable line aware parsing.  This adds tokens that indicate line start and
end points. See <a class="reference internal" href="offside.html#offside"><em>Line&#8211;Aware Parsing and the Offside Rule</em></a>.</div></blockquote>
<p><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.lexer">.config.lexer()</a> <a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.no_lexer">.config.no_lexer()</a></p>
<blockquote>
<div>Detect the use of <a class="reference external" href="api/redirect.html#lepl.lexer.matchers.Token">Token()</a>
and modify the parser to use the lexer. Typically this is called indirectly
via <a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.default">.config.default()</a> (above).</div></blockquote>
<span class="target" id="index-2"></span></div>
<div class="section" id="debug-actions">
<h3>Debug Actions<a class="headerlink" href="#debug-actions" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.full_first_match">.config.full_first_match()</a>
<a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.no_full_first_match">.config.no_full_first_match()</a></p>
<blockquote>
<div>Enable or disable the automatic generation of an error if the first match
fails.</div></blockquote>
<p><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.trace_variables">.config.trace_variables()</a></p>
<blockquote>
<div>Add a monitor that works with the <a class="reference external" href="api/redirect.html#lepl.matchers.variables.TraceVariables">TraceVariables()</a> context to show how
matchers bind to values.  Very useful and included by default.</div></blockquote>
<p><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.trace_stack">.config.trace_stack()</a></p>
<blockquote>
<div>Add a monitor to trace stack use (lots of complex output; not very useful).
See <a class="reference external" href="api/redirect.html#lepl.core.trace.TraceStack">TraceStack()</a>.  Removed by <a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.remove_all_monitors">.config.remove_all_monitors()</a> or
<a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.clear">.config.clear()</a>.</div></blockquote>
<p><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.record_deepest">.config.record_deepest()</a></p>
<blockquote>
<div>Add a monitor to record deepest match.  See <a class="reference external" href="api/redirect.html#lepl.core.trace.RecordDeepest">RecordDeepest()</a>. Removed by
<a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.remove_all_monitors">.config.remove_all_monitors()</a> or
<a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.clear">.config.clear()</a>.</div></blockquote>
</div>
<div class="section" id="optimisation-actions">
<span id="index-3"></span><h3>Optimisation Actions<a class="headerlink" href="#optimisation-actions" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.flatten">.config.flatten()</a>
<a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.no_flatten">.config.no_flatten()</a></p>
<blockquote>
<div><p>Combined nested <a class="reference external" href="api/redirect.html#lepl.matchers.combine.And">And()</a> and
<a class="reference external" href="api/redirect.html#lepl.matchers.combine.Or">Or()</a> matchers.</p>
<p>Nested matchers typically occur because each <tt class="docutils literal"><span class="pre">&amp;</span></tt> and <tt class="docutils literal"><span class="pre">|</span></tt> operator
generates a new matcher, so a sequence of matchers separated by <tt class="docutils literal"><span class="pre">&amp;</span></tt>, for
example, generates several <a class="reference external" href="api/redirect.html#lepl.matchers.combine.And">And()</a> functions.  This rewriter
moves them into a single matcher, as might be expected from reading the
grammar.  This should not change the &#8220;meaning&#8221; of the grammar or the results
returned and is included by default.</p>
</div></blockquote>
<p><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.compile_to_dfa">.config.compile_to_dfa()</a>
<a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.compile_to_nfa">.config.compile_to_nfa()</a>
<a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.compile_to_re">.config.compile_to_re()</a>
<a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.no_compile_to_regexp">.config.no_compile_to_regexp()</a></p>
<blockquote>
<div><p>Compile simple matches to regular expressions.</p>
<p>There are various restrictions about which matchers can be translated to
regular expressions.  The most important are that regular expressions cannot
include recursive loops or transformations.  So rewriting of regular
expressions is typically restricted to those parts of the parser that
recognise individual words.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.compile_to_dfa">.config.compile_to_dfa()</a> may
affect the parser semantics because the DFA engine does not support
backtracking.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.compile_to_re">.config.compile_to_re()</a> uses
the Python <cite>re</cite> library, which cannot handle streams of data in the same
way as Lepl.  This means that matching using that library is restricted
to strings only and does not support backtracking.</p>
</div>
</div></blockquote>
<p><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.optimize_or">.config.optimize_or()</a>
<a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.no_optimize_or">.config.no_optimize_or()</a></p>
<blockquote>
<div><p>Rearrange arguments to <a class="reference external" href="api/redirect.html#lepl.matchers.combine.Or">Or()</a>
so that left-recursive matchers are tested last.  This improves efficiency,
but may alter the parser semantics (the ordering of multiple results with
ambiguous grammars may change).</p>
<p>The <tt class="docutils literal"><span class="pre">conservative</span></tt> parameter supplied to this rewriter indicates how
left&#8211;recursive rules are detected.  If true, all recursive paths are
assumed to be left recursive.  If false then only those matchers that are in
the left&#8211;most position of multiple arguments are used (except for <a class="reference external" href="api/redirect.html#lepl.matchers.combine.Or">Or()</a>).</p>
</div></blockquote>
<p><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.direct_eval">.config.direct_eval()</a>
<a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.no_direct_eval">.config.no_direct_eval()</a></p>
<blockquote>
<div>Combine simple matchers so that they are evaluated without
trampolining.  This is included by default.</div></blockquote>
<p><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.compose_transforms">.config.compose_transforms()</a>
<a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.no_compose_transforms">.config.no_compose_transforms()</a></p>
<blockquote>
<div><p>Combine transforms (functions applied to results) with matchers.</p>
<p>The <a class="reference external" href="api/redirect.html#lepl.matchers.transform.Transform">Transform()</a> matcher is
the &#8220;workhorse&#8221; that underlies <a class="reference external" href="api/redirect.html#lepl.matchers.derived.Apply">Apply()</a>, <tt class="docutils literal"><span class="pre">&gt;</span></tt>, etc.  It changes
the results returned by other functions.</p>
<p>Because transforms are not involved in the work of matching &#8212; they just
modify the final results &#8212; the effects of adjacent instances can be
combined into a single operation.  In some cases they can also be merged
into the operation of another matcher.  This is done by the
<a class="reference external" href="api/redirect.html#lepl.core.rewriters.ComposeTransforms">ComposeTransforms()</a> rewriter.</p>
<p>These operations should not change the &#8220;meaning&#8221; of the grammar or the
results returned, but should improve performance by reducing the amount of
<a class="reference internal" href="implementation.html#trampolining"><em>Trampolining</em></a> made by the parser.  They are included by default.</p>
</div></blockquote>
<p><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.auto_memoize">.config.auto_memoize()</a>
<a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.left_memoize">.config.left_memoize()</a>
<a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.right_memoize">.config.right_memoize()</a>
<a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.no_memoize">.config.no_memoize()</a></p>
<blockquote>
<div>Remember previous inputs and results for matchers so that work is not
repeated.  See <a class="reference internal" href="#memoisation"><em>Memoisation</em></a>.</div></blockquote>
<p><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.low_memory">.config.low_memory()</a></p>
<blockquote>
<div><p>Reduce memory use by explicitly managing resources and discarding old
generators.  See <a class="reference external" href="api/redirect.html#lepl.core.manager.GeneratorManager">GeneratorManager()</a>. Removed by
<a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.remove_all_monitors">.config.remove_all_monitors()</a> or
<a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.clear">.config.clear()</a>.</p>
<p>While this will reduce memory use it also restricts backtracking and may
mean that some inputs cannot be matched.</p>
</div></blockquote>
<p><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.cache_level">.config.cache_level()</a></p>
<blockquote>
<div>Control when streams are retained for debugging output.  This is called by
<a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.low_memory">.config.low_memory()</a> when appropriate (the streams can provide useful
diagnostics, but increase memory use).</div></blockquote>
</div>
<div class="section" id="low-level-actions">
<span id="index-4"></span><h3>Low Level Actions<a class="headerlink" href="#low-level-actions" title="Permalink to this headline">¶</a></h3>
<p>These methods are used internally.  They may also be useful if you are
developing a completely new functionality that is not supported by the &#8220;higher
level&#8221; actions described above.</p>
<p><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.add_rewriter">.config.add_rewriter()</a>
<a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.remove_rewriter">.config.remove_rewriter()</a>
<a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.remove_all_rewriters">.config.remove_all_rewriters()</a></p>
<blockquote>
<div>Add or remove a rewriter, or remove all rewriters (possibly of a given
type).  Rewriters manipulate the matchers before the parser is used.  This
allows Lepl to use some of the techniques that make &#8220;compiled&#8221; parsers more
efficient &#8212; but it can also introduce quite subtle errors.  The addition
of user&#8211;defined rewriters is not encouraged unless you are <em>very</em> familiar
with Lepl.</div></blockquote>
<p><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.add_monitor">.config.add_monitor()</a>
<a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.remove_all_monitors">.config.remove_all_monitors()</a></p>
<blockquote>
<div>Add a monitor, or remove all monitors.  Monitors implement a callback
interface that receives information about how Lepl is working.  They can be
used to share state across matchers, or to generate debugging information,
for example.</div></blockquote>
<p><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.stream_factory">.config.stream_factory()</a></p>
<blockquote>
<div>Set the stream factory.  This changes the class used to generate the stream
for the parser, given some input (for example, <a class="reference external" href="api/redirect.html#lepl.core.config.ParserMixin.parse_string">matcher.parse_string()</a>
will call the <tt class="docutils literal"><span class="pre">from_string()</span></tt> method on this factory, to convert the
string into a suitable stream).</div></blockquote>
<p><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.add_stream_kargs">.config.add_stream_kargs()</a> <a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.remove_all_stream_kargs">.config.remove_all_stream_kargs()</a></p>
<blockquote>
<div>Add additional arguments that are passed to the stream factory.</div></blockquote>
<p><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.alphabet">.config.alphabet()</a></p>
<blockquote>
<div>Set the alphabet, used by rgegular expressions.  The default alphabet is
suitable for Unicode data.</div></blockquote>
</div>
<div class="section" id="argument-actions">
<span id="index-5"></span><h3>Argument Actions<a class="headerlink" href="#argument-actions" title="Permalink to this headline">¶</a></h3>
<p>Sometimes the same argument must be set on many matchers.  Rather that setting
each matcher individually, it is possible to set them all, via the
configuration.  These are used internally, to implement packaged actions;
end-users should not need to call these methods in &#8220;normal&#8221; use.</p>
<p><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.set_arguments">.config.set_arguments()</a>
<a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.no_set_arguments">.config.no_set_arguments()</a></p>
<blockquote>
<div>Set an argument, or clear all such settings.</div></blockquote>
<p><a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.set_alphabet_arg">.config.set_alphabet_arg()</a></p>
<blockquote>
<div>Set the <tt class="docutils literal"><span class="pre">alphabet=...</span></tt> argument.  If no value is given then the value
given earlier to <a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.alphabet">.config.alphabet()</a> (or, if no value was given, the
default Unicode alphabet) is used.</div></blockquote>
</div>
</div>
<div class="section" id="search-and-backtracking">
<span id="backtracking"></span><span id="index-6"></span><h2>Search and Backtracking<a class="headerlink" href="#search-and-backtracking" title="Permalink to this headline">¶</a></h2>
<p>Since Lepl supports full backtracking via generators it is possible to request
all the alternative parses for a given input:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lepl</span> <span class="kn">import</span> <span class="o">*</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">any</span> <span class="o">=</span> <span class="n">Any</span><span class="p">()[:,</span><span class="o">...</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">split</span> <span class="o">=</span> <span class="nb">any</span> <span class="o">&amp;</span> <span class="nb">any</span> <span class="o">&amp;</span> <span class="n">Eos</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match</span> <span class="o">=</span> <span class="n">split</span><span class="o">.</span><span class="n">match_string</span><span class="p">()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">match</span><span class="p">(</span><span class="s">&#39;****&#39;</span><span class="p">)]</span>
<span class="go">[[&#39;****&#39;], [&#39;***&#39;, &#39;*&#39;], [&#39;**&#39;, &#39;**&#39;], [&#39;*&#39;, &#39;***&#39;], [&#39;****&#39;]]</span>
</pre></div>
</div>
<p>This shows that successive parses match less of the input with the first
matcher, indicating that the matching is <em>greedy</em>.</p>
<p><em>Non-greedy</em> (generous?) matching is achieved by specifying an array slice
increment of <tt class="docutils literal"><span class="pre">'b'</span></tt> (or <a class="reference external" href="api/redirect.html#lepl.matchers.operators.BREADTH_FIRST">BREADTH_FIRST</a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">any</span> <span class="o">=</span> <span class="n">Any</span><span class="p">()[::</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">split</span> <span class="o">=</span> <span class="nb">any</span> <span class="o">&amp;</span> <span class="nb">any</span> <span class="o">&amp;</span> <span class="n">Eos</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">split</span><span class="o">.</span><span class="n">parse_all</span><span class="p">(</span><span class="s">&#39;****&#39;</span><span class="p">))</span>
<span class="go">[[&#39;****&#39;], [&#39;*&#39;, &#39;***&#39;], [&#39;**&#39;, &#39;**&#39;], [&#39;***&#39;, &#39;*&#39;], [&#39;****&#39;]]</span>
</pre></div>
</div>
<p>The greedy and non&#8211;greedy repetitions are implemented by depth (default,
<tt class="docutils literal"><span class="pre">'d'</span></tt>, or <a class="reference external" href="api/redirect.html#lepl.matchers.operators.DEPTH_FIRST">DEPTH_FIRST</a>), and breadth&#8211;first
searches (<tt class="docutils literal"><span class="pre">'b'</span></tt> or <a class="reference external" href="api/redirect.html#lepl.matchers.operators.BREADTH_FIRST">BREADTH_FIRST</a>), respectively.</p>
<p>In addition, by specifying a slice increment of <tt class="docutils literal"><span class="pre">'g'</span></tt> (<a class="reference external" href="api/redirect.html#lepl.matchers.operators.GREEDY">GREEDY</a>), you can request a
<em>guaranteed greedy</em> match.  This evaluates all possibilities, before returning
them in reverse length order.  Typically this will be identical to
depth&#8211;first search, but it is possible for backtracking to produce a longer
match in complex cases &#8212; this final option, by evaluating all cases,
re&#8211;orders the results as necessary.</p>
<p>Specifying <tt class="docutils literal"><span class="pre">'n'</span></tt> (<a class="reference external" href="api/redirect.html#lepl.matchers.operators.NON_GREEDY">NON_GREEDY</a>) gets the reverse
ordering.</p>
<p>The tree implicit in the descriptions &#8220;breadth&#8211;first&#8221; and &#8220;depth&#8211;first&#8221; is
not the AST, nor the tree of matchers, but a tree based on matchers and
streams.  In the case of a single, repeated, match this is easy to visualise:
at any particular node the child nodes are generated by applying the matcher
to the various streams returned by the current match (none if this is a final
node, one for a simple match, several if the matcher backtracks).</p>
<p>So far so good.  Unfortunately the process is more complicated for <a class="reference external" href="api/redirect.html#lepl.matchers.combine.And">And()</a> and <a class="reference external" href="api/redirect.html#lepl.matchers.combine.Or">Or()</a>.</p>
<p>In the case of <a class="reference external" href="api/redirect.html#lepl.matchers.combine.And">And()</a>, the
first matcher is matched first.  The child nodes correspond to the various
(with backtracking) results of this match.  At each child node, the second
matcher is applied, generating new children.  This repeats until the scope of
the <a class="reference external" href="api/redirect.html#lepl.matchers.combine.And">And()</a> terminates at a
depth in the tree corresponding to the children of the last matcher.  Since
<a class="reference external" href="api/redirect.html#lepl.matchers.combine.And">And()</a> fails unless all
matchers match, only the final child nodes are possible results.  As a
consequence, both breadth and depth first searches would return the same
ordering.  The <a class="reference external" href="api/redirect.html#lepl.matchers.combine.And">And()</a> match is
therefore unambiguous and the implementation has no way to specify the
(essentially meaningless) choice between the two searches.</p>
<p>In the case of <a class="reference external" href="api/redirect.html#lepl.matchers.combine.Or">Or()</a> we must
select both the matcher and the result from the results available for that
matcher.  A natural approach is to assign the first generation of children to
the choice of matcher, and the second level to the choice of result for the
(parent) matcher.  Again, this results in no ambiguity between breadth and
depth&#8211;first results.</p>
<p>However, there is also an intuitively attractive argument that breadth&#8211;first
search would return the first results of the different matches, in series,
before considering backtracking.  At the moment I do not see a &#8220;natural&#8221; way
to form such a tree, and so this is not implemented.  Feedback is appreciated.</p>
<div class="section" id="restricting-search">
<span id="index-7"></span><h3>Restricting Search<a class="headerlink" href="#restricting-search" title="Permalink to this headline">¶</a></h3>
<p>Lepl&#8217;s ability to backtrack is powerful, but sometimes it is inefficient.
To improve efficiency you can restrict backtracking in two ways.</p>
<p>First, by using <a class="reference external" href="api/redirect.html#lepl.matchers.combine.First">First()</a>,
you can stop search with the first matcher in a list.  This gives results
similar to <a class="reference external" href="api/redirect.html#lepl.matchers.combine.Or">Or()</a>, but stops at
the first successful matcher.  It can be used inline with the operator <tt class="docutils literal"><span class="pre">%</span></tt>.</p>
<p>Second, by using <a class="reference external" href="api/redirect.html#lepl.matchers.combine.Limit">Limit()</a>,
you can restrict search within a single matcher.  In the simplest form
<a class="reference external" href="api/redirect.html#lepl.matchers.combine.Limit">Limit(matcher)</a> will take
only the first match from a matcher.  A different maximum number of matches
can be specified with the optional <a class="reference external" href="api/redirect.html#lepl.support.lib.count">count</a> argument.</p>
<p><a class="reference external" href="api/redirect.html#lepl.matchers.combine.Limit">Limit()</a> can also be applied
to repetition by specifying the count (normally 1) as a &#8220;slice&#8221; value.  So,
<a class="reference external" href="api/redirect.html#lepl.matchers.combine.Limit">Limit(matcher)</a> is
equivalent to <tt class="docutils literal"><span class="pre">matcher[1:1:1]</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">Real</span><span class="p">()</span><span class="o">.</span><span class="n">parse_all</span><span class="p">(</span><span class="s">&#39;1.2&#39;</span><span class="p">))</span>
<span class="go">[[&#39;1.2&#39;], [&#39;1.&#39;], [&#39;1&#39;]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">Limit</span><span class="p">(</span><span class="n">Real</span><span class="p">())</span><span class="o">.</span><span class="n">parse_all</span><span class="p">(</span><span class="s">&#39;1.2&#39;</span><span class="p">))</span>
<span class="go">[[&#39;1.2&#39;]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">Real</span><span class="p">()[</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">parse_all</span><span class="p">(</span><span class="s">&#39;1.2&#39;</span><span class="p">))</span>
<span class="go">[[&#39;1.2&#39;]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">Limit</span><span class="p">(</span><span class="n">Real</span><span class="p">(),</span> <span class="n">count</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">parse_all</span><span class="p">(</span><span class="s">&#39;1.2&#39;</span><span class="p">))</span>
<span class="go">[[&#39;1.2&#39;], [&#39;1.&#39;]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">Real</span><span class="p">()[</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">parse_all</span><span class="p">(</span><span class="s">&#39;1.2&#39;</span><span class="p">))</span>
<span class="go">[[&#39;1.2&#39;], [&#39;1.&#39;]]</span>
</pre></div>
</div>
</div>
<div class="section" id="excluding-matches">
<span id="index-8"></span><h3>Excluding Matches<a class="headerlink" href="#excluding-matches" title="Permalink to this headline">¶</a></h3>
<p>It is also possible to exclude certain matches.  This does not improve
efficiency (the excluded matches have to be made anyway), but can simplify the
logic of a complex parser.</p>
<p>The <a class="reference external" href="api/redirect.html#lepl.matchers.combine.Difference">Difference()</a>
matcher takes two matchers as arguments.  The first is matched as normal, but
any matches that would also have been matched by the second matcher are
excluded.</p>
<p>A good example, is the emulation of <a class="reference external" href="api/redirect.html#lepl.support.warn.Float">Float()</a> using <a class="reference external" href="api/redirect.html#lepl.matchers.derived.Real">Real()</a> and <a class="reference external" href="api/redirect.html#lepl.matchers.derived.Integer">Integer()</a> (remember that <a class="reference external" href="api/redirect.html#lepl.matchers.derived.Real">Real()</a> matches both float and
integer values):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">myFloat</span> <span class="o">=</span> <span class="n">Difference</span><span class="p">(</span><span class="n">Real</span><span class="p">(),</span> <span class="n">Integer</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">myFloat</span><span class="o">.</span><span class="n">parse_all</span><span class="p">(</span><span class="s">&#39;1.2&#39;</span><span class="p">))</span>
<span class="go">[[&#39;1.2&#39;], [&#39;1.&#39;]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">Real</span><span class="p">()</span><span class="o">.</span><span class="n">parse_all</span><span class="p">(</span><span class="s">&#39;1.2))</span>
<span class="go">[[&#39;1.2&#39;], [&#39;1.&#39;], [&#39;1&#39;]]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="memoisation">
<span id="index-9"></span><span id="id29"></span><h2>Memoisation<a class="headerlink" href="#memoisation" title="Permalink to this headline">¶</a></h2>
<p>A memoizer stores a matcher&#8217;s results.  If it is called again in the same
context (during backtracking, for example), the stored result can be returned
without repeating the work needed to generate it.  This can improve the
efficiency of the parser.</p>
<p>Lepl 2 has two memoizers.  The simplest is <a class="reference external" href="api/redirect.html#lepl.matchers.memo.RMemo">RMemo()</a> which is a simple cache based
on the stream supplied.</p>
<p>For left&#8211;recursive grammars, however, things are more complicated.  The same
matcher can be called with the same stream at different &#8220;levels&#8221; of recursion
(for full details see <a class="reference internal" href="implementation.html#memoisation-impl"><em>Memoisation</em></a>).  In this case, <a class="reference external" href="api/redirect.html#lepl.matchers.memo.LMemo">LMemo()</a> must be used.</p>
<p>Memoizers can be specified directly in the grammar or they can be added via
several configuration options, described below.</p>
<p>When added directly to the grammar a memoizer only affects the given
matcher(s).  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">matcher</span> <span class="o">=</span> <span class="n">Any</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)[:]</span> <span class="o">&amp;</span> <span class="n">Any</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)[:]</span> <span class="o">&amp;</span> <span class="n">RMemo</span><span class="p">(</span><span class="n">Any</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">)[</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">matcher</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">&#39;aaaabbbb&#39;</span><span class="p">)))</span>
<span class="go">5</span>
</pre></div>
</div>
<p>Here the <a class="reference external" href="api/redirect.html#lepl.matchers.memo.RMemo">RMemo()</a> avoids
re-matching of the &#8220;bbbb&#8221;, but has no effect on the matching of the &#8220;a&#8221;s.</p>
<p>To explicitly apply a memoizer to all matchers use <a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.left_memoize">.config.left_memoize()</a> or
<a class="reference external" href="api/redirect.html#lepl.core.config.ConfigBuilder.right_memoize">.config.right_memoize()</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">VerbPhrase</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">DetPhrase</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">SimpleTp</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">TermPhrase</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Sentence</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span> <span class="k">pass</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">verb</span>        <span class="o">=</span> <span class="n">Literals</span><span class="p">(</span><span class="s">&#39;knows&#39;</span><span class="p">,</span> <span class="s">&#39;respects&#39;</span><span class="p">,</span> <span class="s">&#39;loves&#39;</span><span class="p">)</span>         <span class="o">&gt;</span> <span class="s">&#39;verb&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">join</span>        <span class="o">=</span> <span class="n">Literals</span><span class="p">(</span><span class="s">&#39;and&#39;</span><span class="p">,</span> <span class="s">&#39;or&#39;</span><span class="p">)</span>                          <span class="o">&gt;</span> <span class="s">&#39;join&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proper_noun</span> <span class="o">=</span> <span class="n">Literals</span><span class="p">(</span><span class="s">&#39;helen&#39;</span><span class="p">,</span> <span class="s">&#39;john&#39;</span><span class="p">,</span> <span class="s">&#39;pat&#39;</span><span class="p">)</span>               <span class="o">&gt;</span> <span class="s">&#39;proper_noun&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">determiner</span>  <span class="o">=</span> <span class="n">Literals</span><span class="p">(</span><span class="s">&#39;every&#39;</span><span class="p">,</span> <span class="s">&#39;some&#39;</span><span class="p">)</span>                      <span class="o">&gt;</span> <span class="s">&#39;determiner&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noun</span>        <span class="o">=</span> <span class="n">Literals</span><span class="p">(</span><span class="s">&#39;boy&#39;</span><span class="p">,</span> <span class="s">&#39;girl&#39;</span><span class="p">,</span> <span class="s">&#39;man&#39;</span><span class="p">,</span> <span class="s">&#39;woman&#39;</span><span class="p">)</span>        <span class="o">&gt;</span> <span class="s">&#39;noun&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">verbphrase</span>  <span class="o">=</span> <span class="n">Delayed</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verbphrase</span> <span class="o">+=</span> <span class="n">verb</span> <span class="o">|</span> <span class="p">(</span><span class="n">verbphrase</span> <span class="o">//</span> <span class="n">join</span> <span class="o">//</span> <span class="n">verbphrase</span><span class="p">)</span>      <span class="o">&gt;</span> <span class="n">VerbPhrase</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">det_phrase</span>  <span class="o">=</span> <span class="n">determiner</span> <span class="o">//</span> <span class="n">noun</span>                             <span class="o">&gt;</span> <span class="n">DetPhrase</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">simple_tp</span>   <span class="o">=</span> <span class="n">proper_noun</span> <span class="o">|</span> <span class="n">det_phrase</span>                       <span class="o">&gt;</span> <span class="n">SimpleTp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">termphrase</span>  <span class="o">=</span> <span class="n">Delayed</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">termphrase</span> <span class="o">+=</span> <span class="n">simple_tp</span> <span class="o">|</span> <span class="p">(</span><span class="n">termphrase</span> <span class="o">//</span> <span class="n">join</span> <span class="o">//</span> <span class="n">termphrase</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">TermPhrase</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sentence</span>    <span class="o">=</span> <span class="n">termphrase</span> <span class="o">//</span> <span class="n">verbphrase</span> <span class="o">//</span> <span class="n">termphrase</span> <span class="o">&amp;</span> <span class="n">Eos</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">Sentence</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">sentence</span><span class="o">.</span><span class="n">left_memoize</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="s">&#39;every boy or some girl and helen and john or pat knows &#39;</span>
<span class="gp">&gt;&gt;&gt; </span>           <span class="s">&#39;and respects or loves every boy or some girl and pat or &#39;</span>
<span class="gp">&gt;&gt;&gt; </span>           <span class="s">&#39;john and helen&#39;</span><span class="p">)))</span>
<span class="go">392</span>
</pre></div>
</div>
<p>This example is left&#8211;recursive and very ambiguous.  With <a class="reference external" href="api/redirect.html#lepl.matchers.memo.LMemo">LMemo()</a> added to all matchers it can be
parsed with no problems.</p>
<p>Because left&#8211;recursive grammars can be very inefficient, and because Lepl&#8217;s
support for them has historically been unreliable (buggy), they are no longer
(since Lepl 5) supported by default.  Instead, <a class="reference external" href="api/redirect.html#lepl.matchers.memo.RMemo">RMemo()</a> is added, which can detect
left&#8211;recursion and print a suitable warning.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Advanced Use</a><ul>
<li><a class="reference internal" href="#configuration">Configuration</a><ul>
<li><a class="reference internal" href="#common-packaged-actions">Common, Packaged Actions</a></li>
<li><a class="reference internal" href="#debug-actions">Debug Actions</a></li>
<li><a class="reference internal" href="#optimisation-actions">Optimisation Actions</a></li>
<li><a class="reference internal" href="#low-level-actions">Low Level Actions</a></li>
<li><a class="reference internal" href="#argument-actions">Argument Actions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#search-and-backtracking">Search and Backtracking</a><ul>
<li><a class="reference internal" href="#restricting-search">Restricting Search</a></li>
<li><a class="reference internal" href="#excluding-matches">Excluding Matches</a></li>
</ul>
</li>
<li><a class="reference internal" href="#memoisation">Memoisation</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="offside.html"
                        title="previous chapter">Line&#8211;Aware Parsing and the Offside Rule</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="style.html"
                        title="next chapter">Patterns</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/advanced.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="style.html" title="Patterns"
             >next</a> |</li>
        <li class="right" >
          <a href="offside.html" title="Line–Aware Parsing and the Offside Rule"
             >previous</a> |</li>
        <li><a href="contents.html">LEPL 5.1.2 documentation</a> &raquo;</li>
          <li><a href="manual.html" >Lepl Manual</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2009-2011, Andrew Cooke.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>